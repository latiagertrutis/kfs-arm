#+LATEX_HEADER: \let\oldsection\section
#+LATEX_HEADER: \renewcommand{\section}{\clearpage\oldsection}
#+LATEX_HEADER: \let\oldsubsection\subsection
#+LATEX_HEADER: \renewcommand{\subsection}{\clearpage\oldsubsection}
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}
#+OPTIONS: \n:t

* Embedded 101
Boot and say hello.

mrodrigu [[mailto:mrodrigu@student.42.fr][mrodrigu@student.42.fr]]

** Chapter I
*** Introduction

Be welcome to *Embedded 101*.



In this project we will introduce you the basics of embedded programming. Here, in the world of the tiny, you will go back to the basics, and code like those mid 80's hackers.

Okay, no kidding, you will need to manage yourself with as much as a couple hundreds of MB of RAM and no more than a MB of flash. So you will learn to be surgical in your programming and be very aware of your available resources. No more infinite virtual memory, hurray!

But, lets ask the question, why is embedded still a thing today in a world where gigs of ram are worth a couple dimes? Well, for us, the users, couple dimes ain't a big deal, but the industry works at a different scale. when you are the big boss of a large company, that needs to build a product in the order of millions, from dishwashers controllers to a car on-board computer, believe me, you will fight for the price of the last damn screw. So here optimizing the resources is critical. If you can squeeze the same logic in half the resources, then you are thinking the right way.

Now a little bit of mapping trough concrete things that you will see in this set of projects. You will learn new concepts embedded (ha ha) to this amazing world: MCUs (we also have CPUs, although they are more rare); GPIOs; CAN bus; serial communications (USART, SPI, and so on); boot loaders, the embedded ones are a bit different many devices need OTA updates; JTAG; and much more.

Here we will work in what is called *bare-metal code*, that is, working without an underlying OS. So you will need to directly access the resources of your MCU from registers (no worries, there are plenty of documentation and HAL libraries provided by the manufacturer, so you don't have to do the mapping yourself). This is the simplest way of starting, and it is the way that the industry has been working with for the past years. As a note, the industry is moving towards using operating systems on
embedded systems, since with the abstraction (oh mighty POSIX!) it is much easier to scale, test, and in general, develop with. But lets go step by step and start from the very basics.

Good luck and have fun!

#+ATTR_LATEX: :width 12cm
[[file:doc/101.jpg]]
