#+LATEX_HEADER: \let\oldsection\section
#+LATEX_HEADER: \renewcommand{\section}{\clearpage\oldsection}
#+LATEX_HEADER: \let\oldsubsection\subsection
#+LATEX_HEADER: \renewcommand{\subsection}{\clearpage\oldsubsection}
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}

#+OPTIONS: \n:t H:4 num:4

* Embedded 101
Boot and say hello.

mrodrigu [[mailto:mrodrigu@student.42.fr][mrodrigu@student.42.fr]]

** Chapter I
*** Introduction to basics

Be welcome to *Embedded 101*.

In this project we will introduce you the basics of embedded programming. Here, in the world of the tiny, you will go back to the basics, and code like those mid 80's hackers.

Okay, no kidding, you will need to manage yourself with as much as a couple hundreds of MB of RAM and no more than a MB of flash. So you will learn to be surgical in your programming and be very aware of your available resources. No more infinite virtual memory, hurray!

But, lets ask the question, why is embedded still a thing today in a world where gigs of ram are worth a couple dimes? Well, for us, the users, couple dimes ain't a big deal, but the industry works at a different scale. when you are the big boss of a large company, that needs to build a product in the order of millions, from dishwashers controllers to a car on-board computer, believe me, you will fight for the price of the last damn screw. So here optimizing the resources is critical. If you can squeeze the same logic in half the resources, then you are thinking the right way.

Now a little bit of mapping trough concrete things that you will see in this set of projects. You will learn new concepts embedded (ha ha) to this amazing world: MCUs (we also have CPUs, although they are more rare); GPIOs; CAN bus; serial communications (USART, SPI, and so on); boot loaders, the embedded ones are a bit different many devices need OTA updates; JTAG; and much more.

Here we will work in what is called *bare-metal code*, that is, working without an underlying OS. So you will need to directly access the resources of your MCU from registers (no worries, there are plenty of documentation and HAL libraries provided by the manufacturer, so you don't have to do the mapping yourself). This is the simplest way of starting, and it is the way that the industry has been working with for the past years. As a note, the industry is moving towards using operating systems on
embedded systems, since with the abstraction (oh mighty POSIX!) it is much easier to scale, test, and in general, develop with. But lets go step by step and start from the very basics.

Good luck and have fun!

#+ATTR_LATEX: :width 12cm
[[file:doc/101.jpg]]

** Chapter II
*** Objectives

Upon completion of this subject you'll have:

- A program that will say "Hello 42!" from the USART
- A HAL (Hardware Abstraction Layer) for controlling the USART peripheral
- A tiny bootloader to initialize the device and run your program
- A linker script (ld) that will link your code for your specific device
- All of the previous combined into an elf file that you will flash in your device


** Chapter III
*** General instructions
**** Real vs Emulated

@@latex:\leavevmode\\@@
It is not mandatory to use any specific device, although it *must be ARM architecture*. You can also run your code in qemu by using the fork for arm ~qemu-system-arm~. If you want to do the project with a real device, ask the staff, they may have some devices prepared for you. If not, you can always buy an evaluation board, they should be inexpensive. If I may suggest, look for stm32 boards, there are many kind in different shapes, and ST has loads of documentation and resources available. Some other alternatives could be from Adafruit or Raspberry. Look over the internet, there are many options!

**** Language

@@latex:\leavevmode\\@@
This project has no specific constraints about the language you can use.

