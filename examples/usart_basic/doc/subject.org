#+LATEX_HEADER: \let\oldsection\section
#+LATEX_HEADER: \renewcommand{\section}{\clearpage\oldsection}
#+LATEX_HEADER: \let\oldsubsection\subsection
#+LATEX_HEADER: \renewcommand{\subsection}{\clearpage\oldsubsection}
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}
#+LATEX_HEADER: \usepackage[x11names]{xcolor}
#+LATEX_HEADER: \hypersetup{linktoc = all, colorlinks = true, urlcolor = DodgerBlue1, citecolor = PaleGreen1, linkcolor = black}

#+OPTIONS: \n:t H:4 num:4 toc:nil

#+TOC: headlines 4

* Embedded 101
Boot and say hello.

mrodrigu [[mailto:mrodrigu@student.42.fr][mrodrigu@student.42.fr]]

** Chapter I
*** Introduction to basics

Be welcome to *Embedded 101*.

In this project we will introduce you to the basics of embedded programming. Here, in the world of the tiny, you will go back to the basics, and code like those mid 80's hackers.

Okay, no kidding, you will need to manage yourself with as much as a couple hundreds of MB of RAM and no more than a MB of flash. So you will learn to be surgical in your programming and be very aware of your available resources. No more infinite virtual memory, hurray!

But, lets ask the question, why is embedded still a thing today in a world where gigs of RAM are worth a couple dimes? Well, for us, the users, couple dimes ain't a big deal, but the industry works at a different scale. When you are the big boss of a large company that needs to build a product in the order of millions, from dishwashers controllers to cars on-board computers, believe me, you will fight for the price of the last damn screw. So here optimizing the resources is critical. If you can squeeze the same logic in half the resources, then you are thinking the right way.

Now a little bit of mapping trough concrete things that you will see in this set of projects. You will learn new concepts embedded (ha ha) to this amazing world: MCUs (we also have CPUs, although they are more rare); GPIOs; CAN bus; serial communications (USART, SPI, and so on); boot loaders, the embedded ones are a bit different many devices need OTA updates; JTAG; and much more.

Here we will work in what is called *bare-metal code*, that is, working without an underlying OS. So you will need to directly access the resources of your MCU from registers (no worries, there are plenty of documentation and HAL libraries provided by the manufacturer, so you don't have to do the mapping yourself). This is the simplest way of starting, and it is the way that the industry has been working for the past years. As a note, the industry is moving towards using operating systems on
embedded systems, since with the abstraction (oh mighty POSIX!) it is much easier to scale, test, and in general, develop with. But lets go step by step and start from the very basics.

Good luck and have fun!

#+ATTR_LATEX: :width 12cm
[[file:doc/101.jpg]]

** Chapter II
*** Objectives

Upon completion of this subject you'll have:

- A program that will say "Hello 42!" from the USART
- A HAL (Hardware Abstraction Layer) for controlling the USART peripheral
- A tiny bootloader to initialize the device and run your program
- A linker script (ld) that will link your code for your specific device
- All of the previous combined into an elf file that you will flash in your device


** Chapter III
*** General instructions
**** Real vs Emulated

@@latex:\leavevmode\\@@
It is not mandatory to use any specific device, although it *must be ARM architecture*. You can also run your code in qemu by using the fork for arm ~qemu-system-arm~. If you want to do the project with a real device, ask the staff, they may have some devices prepared for you. If not, you can always buy an evaluation board, they should be inexpensive. If I may suggest, look for stm32 boards, there are many kind in different shapes, and ST has loads of documentation and resources available. Some other alternatives could be from Adafruit or Raspberry. Look over the internet, there are many options!

**** Language and Environment

@@latex:\leavevmode\\@@
This project has no specific constraints about the language you can use. Although I suggest you to really give a thought to your options. Consider that almost all manufacturers provide their mappings in C/C++ format, and you can imagine how many macros mapping addresses there are in those files (I do not want to even start counting), so you would need a way to translate those. At this level you will not have any kind of abstraction whatsoever, so the language of your choice must be capable (and comfortable) of working in this environment. Not mentioning that most of the documentation is written for C so choose wisely.

In the embedded world there are many, how could I call it... "shortcuts", that auto-generate code for your specific device through evil graphic interfaces, making the user completely disregard what is happening in the background. But we are not here to be that kind of developer, am I right? We are here for being the fighters in the trenches, and building things from scratch. So, it is *forbidden* to use any of those tools. You must *understand* all parts of your code, and seek for the *bare minimum setup* that gets your code working.

**** Compilation

@@latex:\leavevmode\\@@
You can use any compiler, depending on the language you use. It is common for C to use ~arm-none-eabi-gcc~. A *Makefile* must be turned in to compile and link the project.

The following flags *must* be present in order to build and link your binary:

- ARM options:
  - ~-mcpu=xxx~
  - ~-mthumb~
- C options:
  - ~-fno-builtin~
- Linker options:
  - ~-nostdlib~
  - ~-nodefaultlibs~

In the ~-mcpu~ flag make sure to substitute ~xxx~ by the MCU type you are using, for example, ~-mcpu=cortex-m4~.

**** Linking

@@latex:\leavevmode\\@@
Each MCU requires his own linker script, so you must write your own based on the MCU documentation. It is *forbidden* to use a generated linker script. You must try to write a linker script as minimal as possible.

**** Architecture

@@latex:\leavevmode\\@@
ARM architecture is *mandatory*.

**** Documentation

@@latex:\leavevmode\\@@
There is a lot of documentation available online. Make sure to look at the manufacturer's web site for your specific model, they usually offer not only data sheets and user manuals, but a lot of resources and libraries from which you can get (most of the time) nice ideas for your code. As for my part, here are some useful resources I use:
- [[https://wiki.osdev.org/ARM_Overview][OSDev]]
- [[https://microcontrollerslab.com/][Microcontrolerslab]]
- For any POSIX related consultations, just go to the source: [[https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/][Open Group]]


** Chapter IV
*** Mandatory part
**** Base

@@latex:\leavevmode\\@@
